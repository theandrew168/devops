{{ ansible_managed | comment }}

# single-binary deployment: all components run inside of a single process
target: all

# no need for multi-tenancy
auth_enabled: false

server:
  # explicit HTTP port here since caddy needs to match
  http_listen_address: 127.0.0.1
  http_listen_port: 9009

  # don't care about gRPC port, just want to listen locally
  grpc_listen_address: 127.0.0.1

  # allow messages up to 100MB
  grpc_server_max_recv_msg_size: 104857600
  grpc_server_max_send_msg_size: 104857600
  grpc_server_max_concurrent_streams: 1000

distributor:
  # distribute samples based on all labels, as opposed to solely by metric name
  shard_by_all_labels: true

ingester:
  lifecycler:
    # address to advertise for this ingester
    address: 127.0.0.1

    # use an in memory ring store to avoid Consul
    ring:
      kvstore:
        store: inmemory
      replication_factor: 1

    # start immediately and flush on shutdown
    min_ready_duration: 0s
    final_sleep: 0s
    num_tokens: 512

ingester_client:
  grpc_client_config:
    # allow messages up to 100MB
    max_recv_msg_size: 104857600
    max_send_msg_size: 104857600
    grpc_compression: gzip

storage:
  # use the blocks storage engine
  engine: blocks

blocks_storage:
  # use S3-compatible storage for blocks
  backend: s3
  s3:
    endpoint: '{{ cortex_s3_endpoint }}'
    access_key_id: '{{ cortex_s3_access_key_id }}'
    secret_access_key: '{{ cortex_s3_secret_access_key }}'
    bucket_name: '{{ cortex_s3_bucket_name }}'

  bucket_store:
    # configure block synchronization dir
    sync_dir: /tmp/cortex/tsdb-sync

  tsdb:
    # configure local TSDB dir
    dir: /tmp/cortex/tsdb

compactor:
  # configure block compaction dir
  data_dir: /tmp/cortex/compactor

limits:
  # limit metric retention
  compactor_blocks_retention_period: {{ cortex_retention }}
